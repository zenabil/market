
/**
 * @fileoverview Firestore Security Rules for Tlemcen Smart Supermarket.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data (users, addresses, orders)
 * and provides public read access for product and category information. Administrative privileges are managed
 * via a dedicated `/roles_admin/{userId}` collection.
 *
 * Data Structure:
 * - `/products/{productId}`: Publicly readable product information. Contains `purchasePrice` which is only readable/writable by admins.
 * - `/products/{productId}/reviews/{reviewId}`: Publicly readable, owner-writable reviews.
 * - `/categories/{categoryId}`: Publicly readable category information.
 * - `/recipes/{recipeId}`: Publicly readable recipe information.
 * - `/recipes/{recipeId}/reviews/{reviewId}`: Publicly readable, owner-writable reviews.
 * - `/users/{userId}`: User profile data, accessible only to the user and admins.
 * - `/users/{userId}/addresses/{addressId}`: User addresses, accessible only to the user and admins.
 * - `/users/{userId}/orders/{orderId}`: User orders, accessible only to the user and admins. The `userId` field is denormalized to match the path.
 * - `/users/{userId}/wishlist/{productId}`: User wishlist items, accessible only to the user.
 * - `/users/{userId}/shopping-lists/{listId}`: User shopping lists, accessible only to the user.
 * - `/users/{userId}/notifications/{notificationId}`: User notifications, accessible only to the user.
 * - `/roles_admin/{userId}`: Collection to store admin user IDs. Existence over content.
 * - `/settings/site`: Global site settings, publicly readable.
 * - `/contactMessages/{messageId}`: Contact form submissions, write-only for users.
 * - `/teamMembers/{memberId}`: Team member information, publicly readable, admin-writable.
 *
 * Key Security Decisions:
 * - Products, Categories, and Reviews are publicly readable.
 * - User listing is disallowed for regular users, but allowed for admins.
 * - Default security posture for ambiguous relationships is strict owner-only access.
 *
 * Denormalization for Authorization:
 * - The `Order` entity should contain a denormalized `userId` field to match the path `/users/{userId}/orders/{orderId}`.
 *   This ensures that rules can validate the relationship between the order and the user without additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows anyone to read product information, but restricts creation, updates, and deletion to admins.
     * Calculated fields like averageRating and reviewCount should only be updated by backend functions.
     * The `purchasePrice` field is restricted to admins only.
     * Admins can create standard products or bundle products.
     * @path /products/{productId}
     * @allow get, list: if true;
     * @allow create, delete: if isAdmin();
     * @allow update: if isAdmin() && isNotUpdatingCalculatedFields() && isProductTypeConsistent();
     * @principle Public read, admin write for products. Protect calculated fields and product type.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin() && request.resource.data.purchasePrice != null;
      allow update: if isAdmin() && isNotUpdatingCalculatedFields() && isProductTypeConsistent() && request.resource.data.purchasePrice != null;
      allow delete: if isAdmin();


      /**
       * @description Allows anyone to read reviews, but only signed-in users can create/update their own.
       * @path /products/{productId}/reviews/{reviewId}
       * @allow get, list: if true;
       * @allow create: if isSignedIn() && isReviewOwner(request.resource.data.userId);
       * @allow update: if isSignedIn() && isReviewOwner(resource.data.userId);
       * @allow delete: if isSignedIn() && isReviewOwner(resource.data.userId);
       * @principle Public read, owner-only write for reviews.
       */
      match /reviews/{reviewId} {
        allow get, list: if true;
        allow create: if isSignedIn() && isReviewOwner(request.resource.data.userId);
        allow update, delete: if isSignedIn() && isReviewOwner(resource.data.userId);
      }
    }

    /**
     * @description Allows anyone to read category information, but restricts creation, updates, and deletion to admins.
     * @path /categories/{categoryId}
     * @allow get, list: if true;
     * @allow create, update, delete: if isAdmin();
     * @principle Public read, admin write for categories.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }
    
    /**
     * @description Allows public read access to recipes, but write access only to admins. Protects calculated fields.
     * @path /recipes/{recipeId}
     * @allow get, list: if true;
     * @allow create, delete: if isAdmin();
     * @allow update: if isAdmin() && isNotUpdatingCalculatedFields();
     * @principle Public read, admin write for recipes.
     */
    match /recipes/{recipeId} {
        allow get, list: if true;
        allow create, delete: if isAdmin();
        allow update: if isAdmin() && isNotUpdatingCalculatedFields();

      /**
       * @description Allows anyone to read recipe reviews, but only signed-in users can create/update their own.
       * @path /recipes/{recipeId}/reviews/{reviewId}
       * @allow get, list: if true;
       * @allow create: if isSignedIn() && isReviewOwner(request.resource.data.userId);
       * @allow update: if isSignedIn() && isReviewOwner(resource.data.userId);
       * @allow delete: if isSignedIn() && isReviewOwner(resource.data.userId);
       * @principle Public read, owner-only write for recipe reviews.
       */
        match /reviews/{reviewId} {
            allow get, list: if true;
            allow create: if isSignedIn() && isReviewOwner(request.resource.data.userId);
            allow update, delete: if isSignedIn() && isReviewOwner(resource.data.userId);
        }
    }

    /**
     * @description Allows a user to read their own document, and admins to read any.
     * Creation is allowed for any signed-in user for their own document.
     * Updates are restricted to the owner for most fields, but admins can update role and loyalty points.
     * Deletion is disallowed.
     * @path /users/{userId}
     * @allow get: if isSignedIn() && (isOwner(userId) || isAdmin());
     * @allow list: if isAdmin();
     * @allow create: if isSignedIn() && isOwner(userId);
     * @allow update: if isSignedIn() && ( (isOwner(userId) && isUpdatingOwnData()) || (isAdmin() && isUpdatingAllowedAdminFields()) );
     * @allow delete: if false; // Generally don't want users to delete their own account record

      /**
       * @description Allows a user to manage their own wishlist.
       * @path /users/{userId}/wishlist/{productId}
       * @allow get, list, create, delete: if isSignedIn() && isOwner(userId);
       * @allow update: if false;
       * @principle Restricts access to a user's own data tree for wishlists.
       */
      match /wishlist/{productId} {
        allow get, list, create, delete: if isSignedIn() && isOwner(userId);
        allow update: if false;
      }
      
      /**
       * @description Allows a user to manage their own shopping lists.
       * @path /users/{userId}/shopping-lists/{listId}
       * @allow get, list, create, update, delete: if isSignedIn() && isOwner(userId);
       * @principle Restricts access to a user's own data tree for shopping lists.
       */
      match /shopping-lists/{listId} {
        allow get, list, create, update, delete: if isSignedIn() && isOwner(userId);
      }
      
      /**
       * @description Allows a user to manage their own notifications. Admins can create notifications.
       * @path /users/{userId}/notifications/{notificationId}
       * @allow get, list, update: if isSignedIn() && isOwner(userId);
       * @allow create: if isAdmin(); // Only admins can create notifications for users
       * @allow delete: if isSignedIn() && isOwner(userId);
       * @principle Restricts access to a user's own notifications.
       */
      match /notifications/{notificationId} {
        allow get, list, update, delete: if isSignedIn() && isOwner(userId);
        allow create: if isAdmin();
      }
    }

    /**
     * @description Allows a user to manage their own addresses.
     * @path /users/{userId}/addresses/{addressId}
     * @allow get, list: if isSignedIn() && isOwner(userId);
     * @allow create: if isSignedIn() && isOwner(userId);
     * @allow update: if isSignedIn() && isExistingOwner(userId);
     * @allow delete: if isSignedIn() && isExistingOwner(userId);
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/addresses/{addressId} {
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows a user to manage their own orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow get, list: if isSignedIn() && (isOwner(userId) || isAdmin());
     * @allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
     * @allow update: if isSignedIn() && (isExistingOwner(userId) || isAdmin()) && request.resource.data.userId == resource.data.userId;
     * @allow delete: if isSignedIn() && isExistingOwner(userId);
     * @principle Restricts access to a user's own orders, validates userId on create/update.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && (isExistingOwner(userId) || isAdmin()) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows admins to manage admin roles. The first user in the system can self-assign the admin role.
     * @path /roles_admin/{userId}
     * @allow get, list: if isAdmin();
     * @allow create: if isSignedIn() && (isAdmin() || isFirstUser());
     * @allow update: if false;
     * @allow delete: if isAdmin();
     * @principle Restricts access to admins only, with a special case for bootstrapping the first admin.
     */
    match /roles_admin/{userId} {
      allow get, list: if isAdmin();
      allow create: if isSignedIn() && (isAdmin() || isFirstUser());
      allow update: if false;
      allow delete: if isAdmin();
    }
    
    /**
     * @description Allows public read access to coupons, but write access only to admins.
     * @path /coupons/{couponId}
     * @allow get, list: if true;
     * @allow create, update, delete: if isAdmin();
     * @principle Public read, admin write for coupons.
     */
    match /coupons/{couponId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }

    /**
     * @description Allows public read access to site settings, but write access only to admins.
     * @path /settings/site
     * @allow get: if true;
     * @allow create, update, delete: if isAdmin();
     * @principle Public read, admin write for site settings.
     */
    match /settings/site {
        allow get: if true;
        allow create, update, delete: if isAdmin();
    }

    /**
     * @description Allows anyone to submit a contact message. Reading and deleting is restricted to admins.
     * @path /contactMessages/{messageId}
     * @allow create: if true;
     * @allow read, update, delete: if isAdmin();
     * @principle Write-only for public users, full access for admins.
     */
    match /contactMessages/{messageId} {
        allow create: if true;
        allow read, update, delete: if isAdmin();
    }
    
    /**
     * @description Allows public read access to team members, but write access only to admins.
     * @path /teamMembers/{memberId}
     * @allow get, list: if true;
     * @allow create, update, delete: if isAdmin();
     * @principle Public read, admin write for team.
     */
    match /teamMembers/{memberId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }
  
  function isReviewOwner(userId) {
    return isOwner(userId) && request.resource.data.userId == request.auth.uid;
  }

  function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
  }

  function isAdmin() {
    return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
  }
  
  function isFirstUser() {
    // This function checks if the 'users' collection is completely empty.
    // It is used to securely allow the very first person who signs up to become an admin.
    return !exists(/databases/$(database)/documents/users);
  }
  
  function isUpdatingOwnData() {
    // Users can't change their own role or calculated stats directly.
    let disallowedFields = ['role', 'orderCount', 'totalSpent', 'loyaltyPoints', 'id', 'registrationDate'];
    let incomingKeys = request.resource.data.keys();
    
    // Check that no disallowed fields are being modified by the user.
    return !incomingKeys.hasAny(disallowedFields);
  }
  
  function isUpdatingAllowedAdminFields() {
    // Admins can update any field except for the calculated stats and unique ID.
    let disallowedFields = ['orderCount', 'totalSpent', 'id', 'registrationDate'];
    let incomingKeys = request.resource.data.keys();
    return !incomingKeys.hasAny(disallowedFields);
  }

  function isNotUpdatingCalculatedFields() {
    // Prevent client-side updates to calculated fields on products or recipes.
    let disallowedFields = ['averageRating', 'reviewCount', 'sold'];
    let incomingKeys = request.resource.data.keys();

    return incomingKeys.hasAll(disallowedFields) == false ||
           (request.resource.data.averageRating == resource.data.averageRating &&
            request.resource.data.reviewCount == resource.data.reviewCount &&
            request.resource.data.sold == resource.data.sold);
  }
  
  function isProductTypeConsistent() {
    // The 'type' of a product (standard or bundle) should not be changed after creation.
    return request.resource.data.type == resource.data.type;
  }
}
