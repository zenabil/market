
/**
 * @fileoverview Firestore Security Rules for Tlemcen Smart Supermarket.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data (users, addresses, orders)
 * and provides public read access for product and category information. Administrative privileges are managed
 * via a dedicated `/roles_admin/{userId}` collection.
 *
 * Data Structure:
 * - `/products/{productId}`: Publicly readable product information.
 * - `/categories/{categoryId}`: Publicly readable category information.
 * - `/users/{userId}`: User profile data, accessible only to the user and admins.
 * - `/users/{userId}/addresses/{addressId}`: User addresses, accessible only to the user and admins.
 * - `/users/{userId}/orders/{orderId}`: User orders, accessible only to the user and admins. The `userId` field is denormalized to match the path.
 * - `/roles_admin/{userId}`: Collection to store admin user IDs. Existence over content.
 * - `/settings/site`: Global site settings, publicly readable.
 *
 * Key Security Decisions:
 * - Products and Categories are publicly readable.
 * - User listing is disallowed for regular users, but allowed for admins.
 * - Default security posture for ambiguous relationships is strict owner-only access.
 *
 * Denormalization for Authorization:
 * - The `Order` entity should contain a denormalized `userId` field to match the path `/users/{userId}/orders/{orderId}`.
 *   This ensures that rules can validate the relationship between the order and the user without additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows anyone to read product information, but restricts creation, updates, and deletion to admins.
     * @path /products/{productId}
     * @allow get, list: if true;
     * @allow create, update, delete: if isAdmin();
     * @principle Public read, admin write for products.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Allows anyone to read category information, but restricts creation, updates, and deletion to admins.
     * @path /categories/{categoryId}
     * @allow get, list: if true;
     * @allow create, update, delete: if isAdmin();
     * @principle Public read, admin write for categories.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Allows a user to read their own document, and admins to read any.
     * Creation is allowed for any signed-in user for their own document.
     * Updates are restricted to the owner for most fields, but admins can update role and loyalty points.
     * Deletion is disallowed.
     * @path /users/{userId}
     * @allow get: if isSignedIn() && (isOwner(userId) || isAdmin());
     * @allow list: if isAdmin();
     * @allow create: if isSignedIn() && isOwner(userId);
     * @allow update: if isSignedIn() && (
     *                  (isOwner(userId) && isUpdatingOwnData()) || 
     *                  (isAdmin() && isUpdatingAllowedAdminFields())
     *                );
     * @allow delete: if false;
     * @principle Enforces document ownership and admin read/limited-write access.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow list: if isAdmin();
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && ( (isOwner(userId) && isUpdatingOwnData()) || (isAdmin() && isUpdatingAllowedAdminFields()) );
      allow delete: if false; // Generally don't want users to delete their own account record
    }

    /**
     * @description Allows a user to manage their own addresses.
     * @path /users/{userId}/addresses/{addressId}
     * @allow get, list: if isSignedIn() && isOwner(userId);
     * @allow create: if isSignedIn() && isOwner(userId);
     * @allow update: if isSignedIn() && isExistingOwner(userId);
     * @allow delete: if isSignedIn() && isExistingOwner(userId);
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/addresses/{addressId} {
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows a user to manage their own orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow get, list: if isSignedIn() && (isOwner(userId) || isAdmin());
     * @allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
     * @allow update: if isSignedIn() && (isExistingOwner(userId) || isAdmin()) && request.resource.data.userId == resource.data.userId;
     * @allow delete: if isSignedIn() && isExistingOwner(userId);
     * @principle Restricts access to a user's own orders, validates userId on create/update.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list: if isSignedIn() && (isOwner(userId) || isAdmin());
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && (isExistingOwner(userId) || isAdmin()) && request.resource.data.userId == resource.data.userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows admins to manage admin roles.
     * @path /roles_admin/{userId}
     * @allow get, list: if isAdmin();
     * @allow create: if isAdmin();
     * @allow update: if false;
     * @allow delete: if isAdmin();
     * @principle Restricts access to admins only.
     */
    match /roles_admin/{userId} {
      allow get, list: if isAdmin();
      allow create: if isAdmin();
      allow update: if false;
      allow delete: if isAdmin();
    }
    
    /**
     * @description Allows public read access to coupons, but write access only to admins.
     * @path /coupons/{couponId}
     * @allow get, list: if true;
     * @allow create, update, delete: if isAdmin();
     * @principle Public read, admin write for coupons.
     */
    match /coupons/{couponId} {
        allow get, list: if true;
        allow create, update, delete: if isAdmin();
    }

    /**
     * @description Allows public read access to site settings, but write access only to admins.
     * @path /settings/site
     * @allow get: if true;
     * @allow create, update, delete: if isAdmin();
     * @principle Public read, admin write for site settings.
     */
    match /settings/site {
        allow get: if true;
        allow create, update, delete: if isAdmin();
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
  }

  function isAdmin() {
    return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
  }
  
  function isUpdatingOwnData() {
    // Users can't change their own role, order count, total spent, or loyalty points directly.
    let disallowedFields = ['role', 'orderCount', 'totalSpent', 'loyaltyPoints'];
    return request.resource.data.keys().diff(resource.data.keys()).hasOnly(disallowedFields) == false;
  }
  
  function isUpdatingAllowedAdminFields() {
    // Admins can only update the role and loyaltyPoints.
    let allowedFields = ['role', 'loyaltyPoints'];
    let receivedKeys = request.resource.data.keys();
    let unchangedKeys = receivedKeys.removeAll(allowedFields);
    // Check if any fields other than the allowed ones are being changed.
    let isChangingDisallowedKey = false;
    for (let key in unchangedKeys) {
      if (request.resource.data[key] != resource.data[key]) {
        isChangingDisallowedKey = true;
        break;
      }
    }
    return !isChangingDisallowedKey;
  }
}
